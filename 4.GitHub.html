<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GH Documentaci√≥n</title>
  <link rel="stylesheet" href="./stylesGH.css">
</head>

<body>
  
  <div class="main__container">
    <div>
      <h1 class="class_indice">Indice</h1>
      <ul class="indice">
        <li> <a href="#1__"> 1. Instalar Git </a> </li>
        <li> <a href="#2__"> 2. Introduccion a la Terminal y Linea de Comandos </a> </li>
        <li> <a href="#3__"> 3. Qu√© es el staging y los repositorios </a> </li>
        <li> <a href="#4__"> 4. Qu√© es un Branch (rama) y c√≥mo funciona un Merge en Git </a> </li>
        <li> <a href="#5__"> 5. Crea un repositorio de Git y has tu primer commit </a> </li>
        <li> <a href="#6__"> 6. Analizar cambios en los archivos de tu proyecto con Git.txt </a> </li>
        <li> <a href="#7__"> 7. Volver en el tiempo en nuestro repositorio utilizando reset y checkout </a> </li>
        <li> <a href="#8__"> 8. Introducci√≥n a las ramas o branches de Git </a> </li>
        <li> <a href="#9__"> 9. Resoluci√≥n de conflictos al hacer un merge </a> </li>
        <li> <a href="#10__"> 10. Uso de GitHub </a> </li>
        <li> <a href="#11__"> 11. Configura tus llaves SSH en local </a> </li>
        <li> <a href="#12__"> 12. Conexion a Github con SSH </a> </li>
        <li> <a href="#13__"> 13. Tags y versiones en Git y GitHub </a> </li>
        <li> <a href="#14__"> 14. Manejo de Ramas en GitHub </a> </li>
        <li> <a href="#15__"> 15. Configurar m√∫ltiples colaboradores en un repositorio de GitHub </a> </li>
        <li> <a href="#16__"> 16. Utilizando Pull Requests en GitHub </a> </li>
        <li> <a href="#17__"> 17. Creando un Fork, contribuyendo a un repositorio </a> </li>
        <li> <a href="#18__"> 18. Ignorar archivos en el repositorio con gitignore </a> </li>
        <li> <a href="#19__"> 19. Tu sitio web p√∫blico con GitHub Pages </a> </li>
        <li> <a href="#20__"> 20. Git Rebase  reorganizando el trabajo realizado </a> </li>
        <li> <a href="#21__"> 21. Git Stash Guardar cambios en memoria y recuperarlos despu√©s </a> </li>
        <li> <a href="#22__"> 22. Git Clean limpiar tu proyecto de archivos no deseados </a> </li>
        <li> <a href="#23__"> 23. Git cherry-pick traer commits viejos al head de un branch </a> </li>
        <li> <a href="#24__"> 24. Reconstruir commits en Git con amend </a> </li>
        <li> <a href="#25__"> 25. Git Reset y Reflog √∫sese en caso de emergencia </a> </li>
        <li> <a href="#26__"> 26. Buscar en archivos y commits de Git con Grep y log </a> </li>
        <li> <a href="#27__"> 27. Comandos y recursos colaborativos en Git y GitHub </a> </li>
      </ul>
    </div>
    
    <h1 class="class_indice segundo">Contenido</h1>
    <div class="parrafos_padre">
<!-- ________________________________________________________________________________________________ -->
      <div class="parrafos">
        <h1 id="1__">1. Instalar Git</h1>
       
        <ol class="parrafo_div">
          <div class="">
            <li>Ultima version: <a target="_blank" href="https://git-scm.com/downloads">Click</a></li>
          </div>
        </ol>
      </div>

<!-- ________________________________________________________________________________________________ -->
      <div class="parrafos">
        <h1 id="2__">2. Introduccion a la Terminal</h1>
        <h2>Comandos b√°sicos:</h2>
        
        <ol class="parrafo_div">
          <div class="">
            <li><strong>pwd</strong>: Ver ruta actual.</li>
            <li><strong>mkdir</strong>: Crea una carpeta (mkdir nombre_carpeta).</li>
            <li><strong>touch</strong>: Crear archivos (touch nombre_archivo).</li>
            <li><strong>rm</strong>: Borrar un archivo o carpeta (rm archivo_a_borrar). Cuidado con este comando, puedo borrar incluso mi disco duro.</li>
            <li><strong>cat</strong>: Ver contenido de un archivo (cat archivo_a_leer).</li>
            <li><strong>ls</strong>: Muestra los archivos de la carpeta actual.</li>
            <li><strong>ls</strong>: -a: Muestra absolutamente todos los archivos.</li>
            <li><strong>ls</strong>: -al: Ver todos los archivos.</li>
            <li><strong>ls</strong>: -l: Ver todos los archivos como una lista.</li>
          </div>
          
          <div class="">
            <li><strong>cd</strong>: Navegar entre carpetas.</li>
            <li><strong>cd /</strong>: Ir a la ruta principal</li>
            <li><strong>cd</strong> o <strong>cd ~</strong> : Ir a la ruta de tu usuario</li>
            <li><strong>cd .. </strong>: Regresa una carpeta.</li>
            <li><strong>history</strong>: Historial de comandos ejecutadis.</li>
            <li><strong>!732</strong>: Ejecutar√≠a el comando numero 732 mostrado en history.</li>
            <li><strong>clear</strong>: limpia la terminal o Ctrl + L</li>
            <li><strong>Tecla Tab</strong>: muestra predicciones posibles de carpetas o comandos;</li>
            <li><strong>--help</strong>: Descubre todos los argumentos de un comando (cat --help).</li>
          </div>
        </ol>
      </div>

      
<!-- ________________________________________________________________________________________________ -->
      <!-- 
      <div class="parrafos">
        <h1 id=""> </h1>
        <h2> </h2>
        
        <ol class="parrafo_div">
          <div class="">
            <li><strong> </strong> </li>
          </div>
          
          <div class="">
            <li><strong> </strong></li>
          </div>
        </ol>
      </div>
       -->
     
       <div class="parrafos">
        <h1 id="3__">3. Qu√© es el staging y los repositorios</h1>
        <h2>Iniciar un repositorio en git: (git init), este comando se encargar√° de 2 cosas:</h2>
        
        <ol class="parrafo_div">
          <div class="">
            <li>Crea una carpeta .git que guarda toda la base de datos con cambios at√≥micos del proyecto.</li>
          </div>
          
          <div class="">
            <li>Crea un √°rea Staging, que guarda temporalmente mis archivos (cuando ejecute un cierto comando) y me permitir√°, m√°s adelante, guardar estos cambios en el repo (tambi√©n con un comando).</li>
          </div>
        </ol>

        <h1>3.1 Ciclo de vida o estados de los archivos en Git:</h1>
        <ol class="parrafo_div">
          <div class="">
            <li><a target="_blank" href="https://platzi.com/tutoriales/1557-git-github/6242-4-estados-del-ciclo-de-vida-de-archivos-git/">Click</a></li>
          </div>
        </ol>

        <h1>3.2 Comandos para mover archivos entre los estados de Git:</h1>
        <ol class="parrafo_div">
          <div class="">
            <li>git status: ver el estado de mis archivos/carpetas.</li>
            <li>git add: Ayuda a mover archivos del Untracked o Unstaged al estado Staged.</li>
            <li>-- git add nameFile : agrega archivos/carpetas individuales</li>
            <li>-- git add -A : mueve todos los archivos del proyecto (Untrackeds o unstageds).</li>
            <li>git reset HEAD: ayuda a sacar archivos del estado Staged para devolverlos a su estado anterior. Si los archivos ven√≠an de Unstaged, vuelven all√≠. Y lo mismo se ven√≠an de Untracked.</li>
          </div>

          <div class="">
            <li>git commit: ayuda a mover archivos de Unstaged a Tracked. Esta es una ocasi√≥n especial, los archivos han sido guardados o actualizados en el repo. git commit -m "mensaje"</li>
            <li>git rm: este comando necesita alguno de los siguientes argumentos para poder ejecutarse:</li>
            <li>-- git rm --cached: Mueve los archivos que le indiquemos al estado Untracked.</li>
            <li>-- git rm --force: Elimina los archivos de Git y del disco duro. Git guarda el registro de la existencia de los archivos, por lo que podremos recuperarlos si es necesario (pero debemos usar comandos m√°s avanzados).</li>
          </div>
        </ol>
      </div>
      </div>
<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="4__">4. Qu√© es un Branch (rama) y c√≥mo funciona un Merge en Git</h1>
        <ol class="parrafo_div">
          <div class="">
            <li>Git: base de datos muy precisa con todos los cambios y crecimiento que ha tenido mi proyecto. Los commits son la √∫nica forma de tener un registro de los cambios. Pero las ramas amplifican mucho m√°s el potencial de Git.</li>
            <li>Todos los commits se aplican sobre una rama. Por defecto, inicio en la rama master(se puede cambiar el nombre) y creo nuevas ramas a partir de esta, para crear flujos de trabajo independientes.</li>
            <li>Los equipos de desarrollo tienen un est√°ndar: Todo lo que est√© en la rama master va a producci√≥n, las nuevas features, caracter√≠sticas y experimentos van en una rama ‚Äúdevelopment‚Äù (para unirse a master cuando est√©n definitivamente listas) y los issues o errores se solucionan en una rama ‚Äúhotfix‚Äù para unirse a master tan pronto como sea posible.</li>
          </div>

          <div class="">
            <li>Crear una nueva rama lo conocemos como Checkout. Unir dos ramas lo conocemos como Merge.</li>
            <li>Puedo crear todas las ramas y commits que quiera. De hecho, puedo aprovechar el registro de cambios de Git para crear ramas, traer versiones viejas del c√≥digo, arreglarlas y combinarlas de nuevo para mejorar el proyecto.</li>
            <li>Solo ten en cuenta que combinar estas ramas puede generar conflictos. Algunos archivos pueden ser diferentes en ambas ramas. Git es muy inteligente y puede intentar unir estos cambios autom√°ticamente, pero no siempre funciona. En algunos casos, nosotros debemos resolver estos conflictos ‚Äúa mano‚Äù.</li>
          </div>
        </ol>
      </div>
         -->
<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="5__">5. Crea un repositorio de Git y has tu primer commit</h1>
        <ol class="parrafo_div">
          <div class="">
            <li>git init: en la carpeta que vamos a trabajar</li>
            <li>-- ls -al: ver todas las carpetas</li>
          </div>
          <div class="">
            <li>-- code: abre vscode</li>
          <li>-- code archivo.js: abre ese archivo.</li>
          </div>
        </ol>

        <ol class="parrafo_div">
          <div class="">
            <li>git status: Ver el estado de mis archivos</li>
          </div>
          <div class="">
            <li>git add nombrearchivo: agrega archivo en especifico</li>
          </div>
        </ol>

        <ol class="parrafo_div">
          <div class="">
            <li>Una de estas dos opciones por si quiero revertir el add.</li>
            <li>-- git rm nombrearchivo: aun no elimina el archivo, pero debo decirle que hacer con el, si agregarlo o eliminarlo</li>
          </div>
          <div class="">
            <li>-- git rm --cached nombrearchivo: cached significa que esta guardado aun en memoria ram, usamos este para quitarle el 'add' es para revertir</li>
          </div>
        </ol>

        <ol class="parrafo_div">
          <div class="">
            <li>Podr√≠a usar una de estas dos opciones por si quiero subir los cambios ya al repo.</li>
            <li>-- git commit: commit sin mensaje</li>
          </div>
          <div class="">
            <li>-- git commit -m "mensaje": sube el commit con un mensaje caracteristico.</li>
          </div>
        </ol>

        <ol class="parrafo_div">
          <li>Cambiar configuracion del usuario de git.</li>
          <li>-- git config: Para ver todas las configuraciones que tiene git</li>
          <li>-- git config --list: para ver la configuracion por defecto</li>
          <li>-- git config --global user.name "myName": registra mi nombre en git</li>
          <li>-- git config --global user.email "correo@gmail.com": registra correo</li>
        </ol>
        <ol class="parrafo_div"><li>git log: Ver commits hechos.</li></ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
     <!--  <div class="parrafos">
        <h1 id="6__">6. Analizar cambios en los archivos de tu proyecto con Git.txt</h1>
        <ol class="parrafo_div">
          <li>git show nameFile: muestra los cambios que han existido sobre un archivo.</li>
          <li>git commit: cuando hacemos un commit sin mensaje, abre la consola de vim</li>
          <li>-- Si no deja escribir, pulso 'Esc' + 'i' y dejar√° insertar texto, para escribir un commit.</li>
          <li>-- Salgo del editor de texto vim, 'Shift' + 'z' + 'z' y guarda mi mensaje (no se puede enviar un commit vac√≠o)</li>
          <li>git diff hashCommit otroHashCommit: muestra la diferencia entre dos commits.</li>
          <li>git log nombrearchivo</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="7__">7. Volver en el tiempo en nuestro repositorio utilizando reset y checkout</h1>
        <ol class="parrafo_div">
          <li>git reset commitAntiguo --soft: Regresar a la version anterior.</li>
          <li>-- soft deja las cosas en staging, para poder commitearlo la proxima vez.</li>
          <li>git reset commitAntiguo --hard: TODO vuelve a su estado anterior, borra commits que se hicieron desde este commit en adelante.</li>
          <li>git log --stat: ver cambios a partir del commit</li>
          <li>git checkout hashCommit nombreArchivo: Pasa a los cambios de ese commit, puede ser un commit muy antiguo, pero aun no estan borrados los cambios mas recientes, a no ser que hagamos un commit;</li>
          <li>git checkout master nombreArchivo: Regresa al commit actual de nuestro proyecto.</li>
          <li>Salir de (END) prueba con la 'q'</li>
          <li>Recomendacion: cuando est√©n renombrando archivos o cambiando ubicaci√≥n de los archivos dentro del repositorio, utilicen el comando: git mv</li>
          <li>-- Si lo hacen de la forma habitual, se pierde el tracking que hace git y despu√©s se pueden generar bastantes conflictos.</li>
          <li>--- Un ejemplo ser√≠a: git mv nameactual.txt namenuevo.txt</li>
        </ol>
        <h2>Git reset vs Git rm: Git reset y git rm son comandos con utilidades muy diferentes.</h2>
        <ol class="parrafo_div">
          <li>git rm: Eliminar archivos de git sin eliminar su historial del sistema de versiones. Esto quiere decir que si necesitamos recuperar el archivo solo debemos ‚Äúviajar en el tiempo‚Äù y recuperar el √∫ltimo commit antes de borrar el archivo en cuesti√≥n.</li>
          <li>-- git rm no puede usarse as√≠ nom√°s. Debemos usar uno de los flags para indicarle a Git c√≥mo eliminar los archivos que ya no necesitamos en la √∫ltima versi√≥n del proyecto:</li>
          <li>--- -git rm --cached: Elimina los archivos del √°rea de Staging y del pr√≥ximo commit pero los mantiene en nuestro disco duro.</li>
          <li>--- -git rm --force: Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario (pero debemos usar comandos m√°s avanzados).</li>
        </ol>
        <ol class="parrafo_div">
          <li>git reset: Volver en el tiempo. Pero no como git checkout que deja ir, mirar, volver. con reset voy al pasado sin la posibilidad de volver al futuro. Borra la historia y la debe sobreescribir, no hay vuelta atr√°s.</li>
          <li>-- Comando muy peligroso y debe usarlo en caso de emergencia. debe usar alguna de estas dos opciones:</li>
          <li>--- git reset --soft: Borra todo el historial y los registros de Git pero guardamos cambios que tengamos en Staging, as√≠ podemos aplicar las √∫ltimas actualizaciones a un nuevo commit.</li>
          <li>--- git reset --hard: Borra TODO. info de commits...</li>
        </ol>
        <ol class="parrafo_div">
          <li>Aun falta: git reset HEAD: Sacar archivos del Staging. No para borrarlos, solo para que los √∫ltimos cambios de estos archivos no se env√≠en al √∫ltimo commit, a menos que cambiemos de opini√≥n y los incluyamos de nuevo en staging con git add.</li>
          <li>-- ¬øPor qu√© esto es importante?</li>
          <li>--- Imagina lo siguiente: -Hago cambios en un proyecto para una actualizaci√≥n. Todos los archivos con cambios se mueven al √°rea de staging con el comando git add. Pero te das cuenta de que uno de esos archivos no est√° listo todav√≠a. Actualizaste el archivo pero ese cambio no debe ir en el pr√≥ximo commit por ahora.</li>
          <li>-- ¬øQu√© puedo hacer?</li>
          <li>--- Todos los cambios est√°n en Staging, incluido el archivo con los cambios que no est√°n listos. Esto significa que debemos sacar ese archivo de Staging para poder hacer commit de todos los dem√°s.</li>
          <li>--- Al usar git rm lo que haremos ser√° eliminar este archivo completamente de git. Todav√≠a tendr√© el historial de cambios de este archivo, con la eliminaci√≥n del archivo como su √∫ltima actualizaci√≥n. Recuerda que en este caso no busc√°bamos eliminar un archivo, solo dejarlo como estaba y actualizarlo despu√©s, no en este commit.</li>
          <li>--- En cambio, si usamos git reset HEAD, lo √∫nico que haremos ser√° mover estos cambios de Staging a Unstaged. Seguiremos teniendo los √∫ltimos cambios del archivo, el repositorio mantendr√° el archivo (no con sus √∫ltimos cambios pero s√≠ con los √∫ltimos en los que hicimos commit) y no habremos perdido nada.</li>
          <li>--- Conclusi√≥n: Lo mejor que puedes hacer para salvar tu puesto y evitar un incendio en tu trabajo es conocer muy bien la diferencia y los riesgos de todos los comandos de Git.</li>
        </ol>

        <h2>Algunos comandos que pueden ayudar cuando colaboren con proyectos muy grandes de github:</h2>
        <ol class="parrafo_div">
          <li>git log --oneline - Te muestra el id commit y el t√≠tulo del commit.</li>
          <li>git log --decorate- Te muestra donde se encuentra el head point en el log.</li>
          <li>git log --stat - Explica el n√∫mero de l√≠neas que se cambiaron brevemente.</li>
          <li>git log -p- Explica el n√∫mero de l√≠neas que se cambiaron y te muestra que se cambi√≥ en el contenido.</li>
          <li>git shortlog - Indica que commits ha realizado un usuario, mostrando el usuario y el titulo de sus commits.</li>
          <li>git log --graph --oneline --decorate y</li>
          <li>git log --pretty=format:"%cn hizo un commit %h el dia %cd" - Muestra mensajes personalizados de los commits.</li>
          <li>git log -3 - Limitamos el n√∫mero de commits.</li>
          <li>git log --after=‚Äú2018-1-2‚Äù ,</li>
          <li>git log --after=‚Äútoday‚Äù y</li>
          <li>git log --after=‚Äú2018-1-2‚Äù --before=‚Äútoday‚Äù - Commits para localizar por fechas.</li>
          <li>git log --author=‚ÄúName Author‚Äù - Commits realizados por autor que cumplan exactamente con el nombre.</li>
          <li>git log --grep=‚ÄúINVIE‚Äù - Busca los commits que cumplan tal cual est√° escrito entre las comillas.</li>
          <li>git log --grep=‚ÄúINVIE‚Äù ‚Äìi- Busca los commits que cumplan sin importar may√∫sculas o min√∫sculas.</li>
          <li>git log ‚Äì index.html- Busca los commits en un archivo en espec√≠fico.</li>
          <li>git log -S ‚ÄúPor contenido‚Äù- Buscar los commits con el contenido dentro del archivo.</li>
          <li>git log > log.txt - guardar los logs en un archivo txt</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="8__">8. Introducci√≥n a las ramas o branches de Git</h1>
        <ol class="parrafo_div">
          <li>git commit -am "mensaje": add + commit, solo sirve con archivos que alguna vez tuvieron un add.</li>
          <li>git commit -a: es lo mismo que arriba, pero dirige al editor vim para escribir el mensaje.</li>
          <li>git branch nombreRama: Crea una nueva rama, puedo verificarlo con git show aparecera (HEAD -> master, nombreRama)</li>
          <li>git checkout nombreRama: para cambiarnos a la rama previamente creada</li>
          <li>git checkout -b "nombreRama": crea rama y pasa a ella.</li>
          <li>git branch: ver ramas existentes.</li>
          <li>git merge nombre_otraRama: merge entre 2 ramas, me ubico en la rama que quiero que sea principal, para pegar a ella la rama secundaria, luego del merge, se pueden ver los commits que tenian la rama fusionada, es decir estaran los commits de la rama master + los de la rama pegada.</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="9__">9. Resoluci√≥n de conflictos al hacer un merge</h1>
        <ol class="parrafo_div">
          <li>Git nunca borra nada a menos que se le indique. Cuando uso los comandos git merge o git checkout estoy cambiando de rama o creando un nuevo commit, no borrando ramas ni commits (recuerda: borrar commits con git reset y ramas con git branch -d).</li>
          <li>Git es muy inteligente y puede resolver algunos conflictos autom√°ticamente: cambios, nuevas l√≠neas, etc. Pero a veces no sabe c√≥mo resolver las diferencias, Ej: cuando 2 ramas diferentes hacen cambios distintos a una misma l√≠nea.</li>
          <li>Esto se conoce como conflicto y lo puede resolver manualmente, solo debe hacer el merge, ir al editor de c√≥digo y elegir si quiero quedarme con alguna de las 2 versiones o algo diferente. Algunos editores de c√≥digo como VSCode nos ayudan a resolver estos conflictos sin necesidad de borrar o escribir l√≠neas de texto, basta con hundir un bot√≥n y guardar el archivo.</li>
          <li>Recuerda que siempre debe crear un nuevo commit para aplicar los cambios del merge. Si Git puede resolver el conflicto har√° commit autom√°ticamente. Pero, en caso de no pueda resolverlo, debe solucionarlo y hacer el commit.</li>
          <li>Los archivos con conflictos por el comando git merge entran en un nuevo estado que conocemos como Unmerged. Funcionan muy parecido a los archivos en estado Unstaged, algo as√≠ como un estado intermedio entre Untracked y Unstaged, solo debe ejecutar git add para pasarlos al √°rea de staging y git commit para aplicar los cambios en el repositorio.</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="10__">10. Uso de GitHub</h1>
        <ol class="parrafo_div">
          <li>-Crea un repo en GitHub, (readme para explicar el proyecto).</li>
          <li>-Copia el link del repo, (boton verde), opcion de HTTPS.</li>
          <li>-En Git Bash me ubico en la carpeta donde llevo mi proyecto.</li>
          <li>-git remote add origin link-repositorio.</li>
          <li>-git push origin master: digo a git que envie al origen, la rama master.</li>
          <li>-git pull origin master: descarga lo que haya en mi proyecto de GitHub.</li>
          <li>-git pull origin master --allow-unrelated-histories: para casos donde se deban fusionar objetos de github con mi rama. https://www.educative.io/edpresso/the-fatal-refusing-to-merge-unrelated-histories-git-error.</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="11__">11. Configura tus llaves SSH en local</h1>
        <ol class="parrafo_div">
          <li>ssh-keygen -t rsa -b 4096 -C "manuelinperez@gmail.com"</li>
          <li>-- t: algoritmo que usar√© para crear esa llave, rsa es el algoritmo mas popular(segun el video de hace a√±os)</li>
          <li>-- b: que tan compleja sera la llave, 4096 es la complejidad de la llave desde una perspectiva matem√°tica.</li>
          <li>-- C  es a que correo electronico estara conectada esta llave.</li>
          <li>Aparecera un mensaje de generendo llave, y luego:</li>
          <li>-- Enter file in which to save the key (/c/Users/Admin/.ssh/id_rsa): donde deberia guardar la llave; si le doy enter, la guardara en la ruta que aparece.</li>
          <li>Luego: Enter passphrase (empty for no passphrase): Para poner una contrasena con espacios; Si doy enter, no la pondr√°.</li>
          <li>Veo si el proceso corre: eval $(ssh-agent -s) trae algo as√≠ Agent pid 1111; √ì ssh-add ~/.ssh/id_rsa</li>
          <li>Ahora la agregamos ssh-add ~/aquiNombreDeLaKey lo importante es recordar ssh-add pues el resto es la direccion de donde esta guardada la llave</li>
          <li>Listo, ya creamos nuestro entorno local</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="12__">12. Conexion a Github con SSH</h1>
        <ol class="parrafo_div">
          <li>Copiar llave publica, ir a settings de Github, SSH and GPG keys, crear nueva llave, pon un titulo, y pega la llave.</li>
          <li>Luego de vincular, voy a cualquier repo y copio el link, ya no HTTPS, sino en SSH.</li>
          <li>En Git Bash voy a la carpeta del proyecto</li>
          <li>-- git remote -v : para ver mi repo.</li>
          <li>-- git remote set-url origin nuevaUrl : cambiar url del repo.</li>
          <li>Podria hacer alg√∫n cambio en el proyecto, para verificar, pero primero:</li>
          <li>traigo la informacion con git pull, le doy [yes] (Nota: Es bueno leer los mensajes que arroje git)</li>
          <li>Dice que debo especificar algunas cosas:</li>
          <li>--  git pull origin master: traigo origin del remoto y lo fusiono con master.</li>
          <li>Despues si hago un cambio en el proyecto, lo subo con git push origin master</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="13__">13. Tags y versiones en Git y GitHub</h1>
        <ol class="parrafo_div">
          <li>git log --all --graph --decorate --oneline: Veo el resumen de todos los commits incluso los hash son version corta.</li>
          <li>-- Le puedes poner un alias para que sea mas corto:</li>
          <li>--- alias tree="git log --all --graph --decorate --oneline" : alias=alias, tree=aliasQueResumeComando</li>
          <li>git tag -a v0.1 -m "Resultado de las primeras clases del curso" 2178a83 : digo que sera un tag -a=voy a agregar un tag) v0.1=nombreTag -m""=mensajeParaTag 2178a83=hashDelCommit.</li>
          <li>git tag: muestra los tags que tenemos</li>
          <li>git show v1.4 : ver info de ese tag</li>
          <li>Lo mejor es hacer un git pull origin master y luego enviar los tags a GitHub</li>
          <li>git push origin --tags: empujar a origin, los tags que cre√©.</li>
          <li>Se pueden ver los tags en GitHub al lado de donde aparecen las ramas.</li>
          <li>git tag -d nombreTag : borrar el tag. Ese tag no se borra de GitHub</li>
          <li>git push origin :refs/tags/nombreTag : borra el tag 'nombreTag' de GitHub.</li>
          <li>comentarios:</li>
          <li>-- Ejecutan este comando en la terminal y queda guardado en los alias pero de git. con esto se puede ejecutar cada que se escribe git superlog</li>
          <li>--- git config --global alias.superlog "log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all"</li>
          <li>-- Para que sus bonitos alias no se les borren, como a mi. üòÅ</li>
          <li>--- Vayan a la carpeta C:/Usuarios/su_usuario</li>
          <li>--- Revisen que est√© el archivo .bashrc o cr√©enlo desde la consola con touch .bashrc y dentro guarden sus alias de la siguiente manera. Yo lo edit√© en VS Code</li>
          <li>--- Cierren todas sus instancias de Git Bash que tengan abiertas y ¬°listos!</li>
          <li># ----------------------</li>
          <li># Git Command Aliases</li>
          <li># ----------------------</li>
          <li>alias ga='git add'</li>
          <li>alias arbol='git log --all --oneline --graph --decorate'</li>
          <li>alias branches='git branch -l'</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
     <!--  <div class="parrafos">
        <h1 id="14__">14. Manejo de Ramas en GitHub</h1>
        <ol class="parrafo_div">
          <li>git show-branch : Muestra ramas existentes y su historia</li>
          <li>git show-branch --all : Muestra lo mismo que arriba + mas datos</li>
          <li>gitk : Muestra informacion mas grafica/visual de las ramas y su historia</li>
          <li>git push origin nombreDeOtraRama : sube otra rama que quiera</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
     <!--  <div class="parrafos">
        <h1 id="15__">15. Configurar m√∫ltiples colaboradores en un repositorio de GitHub</h1>
        <ol class="parrafo_div">
          <li>Clonar un repositorio, voy al repositorio que quiera, al boton verde y copio el link.</li>
          <li>en Git Bash, git clone linkDelRepo.</li>
          <li>Puede hacer algun cambio al proyecto, y hacer un add y commit.</li>
          <li>Ver que ramas hay, solo traer√° la master.</li>
          <li>git log nos mostrara los commit hechos en ese repo.</li>
          <li>Al hacer un git push origin master se denega el permiso, ya que debe ser miembro. El due√±o del repo debe agregarlo como miembro.</li>
          <li>El due√±o del repo debe ir a los settings del repo, Manage acces, y ahi escribir el nombre de usuario o correo.</li>
          <li>Luego de ser miembro, ya puede empezar a hacer colaboracione</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="16__">16. Utilizando Pull Requests en GitHub</h1>
        <ol class="parrafo_div">
          <li>Pull request: Funcionalidad de github (gitlab: merge request, bitbucket: push request), en la que un colaborador pide que revisen sus cambios antes de hacer merge a una rama.</li>
          <li>Al hacer un pull request se genera una conversaci√≥n que pueden seguir los dem√°s usuarios del repositorio, as√≠ como autorizar y rechazar los cambios.</li>
          <li>El flujo del pull request es el siguiente</li>
          <li>--  Se trabaja en una rama paralela los cambios que se desean (git checkout -b rama)</li>
          <li>--  Se hace un commit a la rama (git commit -am 'Comentario')</li>
          <li>--  Se suben al remoto los cambios (git push origin rama)</li>
          <li>--  En GitHub se hace el pull request comparando la rama master con la rama del fix.</li>
          <li>--  Uno, o varios colaboradores revisan que el c√≥digo sea correcto y dan feedback (en el chat del pull request)</li>
          <li>--  El colaborador hace los cambios que desea en la rama y lo vuelve a subir al remoto (autom√°ticamente jala la historia de los cambios que se hagan en la rama, en remoto)</li>
          <li>--  Se aceptan los cambios en GitHub</li>
          <li>--  Se hace merge a master desde GitHub</li>
          <li>Importante: Cuando se modifica una rama, tambi√©n se modifica el pull request</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="17__">17. Creando un Fork, contribuyendo a un repositorio</h1>
        <ol class="parrafo_div">
          <li>Click en fork del repo que me guste.</li>
          <li>en a la consola: git clone link_copiado</li>
          <li>cuando hay una sola rama, se puede hacer git push, pues solo hay una.</li>
          <li>recuerda que mientras el repo original vaya haciendo cambios, debes traerlos al clon, para no quedar desactualizado.</li>
          <li>Puedes ver desde la seccion "code" un texto que dice:</li>
          <li>-- "This branch is 4 commits behind due√±odelrepo:master" significa que tenemos 4 commits detras del due√±o del repo</li>
          <li>-- los puedo comparar, al hacerlo saldra que no se puede, porque esta comparando de mi repo al original, deberia ser al reves.</li>
          <li>-- Se puede dar en el link "switching the base" y mostrar√° los cambios.</li>
          <li>-- Para solucionarlo, puedes darle en "Create pull request" o desde consola.</li>
          <li>-- consola: Crea otra fuente para hacer pull, ve al proyecto original y copia el link, git remote add upstream link_copiado (upstream: nombre que quiera colocar, es como el origin)</li>
          <li>-- si doy git remote -v puedes ver esa rama nueva llamada upstream y ya deberia poder hacergit pull de mi upstream a mi rama master (git pull upstream master)  </li>
          <li>-- git add, commit y push origin master</li>
          <li>-- Listo! Ya deberia estar guardado y actualizado</li>
          <li>Comentario:</li>
          <li>Forks/Bifurcaciones:</li>
          <li>Caracter√≠stica √∫nica de GitHub en la que se crea una copia exacta del estado actual de un repo directamente en GitHub, este repo podr√° servir como otro origen y se podr√° clonar (como cualquier otro repo), en pocas palabras, lo puede utilizar como un git cualquiera.</li>
          <li>Un fork es una bifurcaci√≥n del repo completo, tiene una historia en com√∫n, pero de repente se bifurca y pueden variar los cambios, ya que ambos proyectos podr√°n ser modificados en paralelo y para estar al d√≠a un colaborador tendr√° que estar actualizando su fork con la informaci√≥n del original. </li>
          <li>Al hacer fork de un poryecto en GitHub, te conviertes en due√±o del repo fork, puedes trabajar en este con todos los permisos, pero es un repo completamente diferente que el original, teniendo alguna historia en com√∫n.</li>
          <li>Los forks son importantes porque es la manera en la que funciona el open source, pues una persona puede no ser colaborador de un proyecto, pero puede contribu√≠r al mismo.</li>
          <li>Al hacer un fork, GitHub sabe que se hizo el fork del proyecto, por lo que se le permite al colaborador hacer pull request desde su repo propio.</li>
          <li>Cuando trabajas en un proyecto que existe en diferentes repos remotos (normalmente a causa de un fork) es muy probable que desees poder trabajar con ambos repos, para √©sto puedes crear un remoto adicional desde consola.</li>
          <li>--  git remote add nombreDelRemoto urlDelRemoto</li>
          <li>--  git remote upstream https://github.com/freddier/hyperblog</li>
          <li>--  Al crear un remoto adicional podr√©, hacer pull desde el nuevo origen (si tienes permisos puedes hacer fetch y push)</li>
          <li>--  git pull remoto rama</li>
          <li>--  git pull upstream master</li>
          <li>Este pull traer√° los cambios del remoto, por lo que estar√° al d√≠a en el proyecto, el flujo de trabajo cambia, en adelante se estar√° trabajando haciendo pull desde el upstream y push al origin para pasar a hacer pull request.</li>
          <li>git pull upstream master</li>
          <li>git push origin master</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
     <!--  <div class="parrafos">
        <h1 id="18__">18. Ignorar archivos en el repositorio con gitignore</h1>
        <ol class="parrafo_div">
          <li>crear un archivo llamado .gitignore</li>
          <li>-- Ej de uso: *.jpg : ignore todos los archivos .jpg</li>
          <li>Notas: </li>
          <li>-- Readme.md es buena practica, un buen editor de readme: https://pandao.github.io/editor.md/en.html </li>
          <li>-- Subir los archivos pesados como imagenes y videos, a alojamientos y linkar, no subirlo a github</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
    <!--   <div class="parrafos">
        <h1 id="19__">19. Tu sitio web p√∫blico con GitHub Pages</h1>
        <ol class="parrafo_div">
          <li>https://pages.github.com/ Lee las instrucciones.</li>
          <li>Creas un repo, clonas, entras y creamos un html -- vim index.html con algun codigo</li>
          <li>http://miguesc2.github.io/ voy a setting del repo, bajo a la seccion de GitHub Pages</li>
          <li>Escoge master, y guardas, dar√° el link de mi pagina.</li>
          <li>Para que cargue desde mi raiz, debo cambiar el nombre del repo a algo asi: nombredeusuario.github.io</li>
          <li>algunos portafolios de los comments:  </li>
          <li>-- https://iamdulce.github.io/portfolio/</li>
          <li>-- https://mistyblunch.github.io/</li>
          <li>-- https://mhsantosp.github.io/dai_clover/</li>
        </ol>
      </div> -->
      
<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="20__">20. Git Rebase  reorganizando el trabajo realizado</h1>
        <ol class="parrafo_div">
          <li>Mala practica**</li>
          <li>Git rebase recopila uno a uno los cambios confirmados en una rama, y reaplicarlos sobre otra. Utilizar rebase nos </li>
          <li>puede ayudar a evitar conflictos siempre que se aplique sobre commits que est√°n en local y no han sido subidos a ning√∫n repositorio remoto.</li>
          <li>Comment: </li>
          <li>-- rebase reescribe la historia del repositorio, cambia la historia de donde comenz√≥ la rama y solo debe ser usado de manera local.</li>
          <li>-- Si estoy ubicado en la rama que quiero unir, podr√© hacer este c√≥digo, ejemplo, estoy ubicado en la rama "experimento" pues estando en esa rama har√© git rebase master para copiar la informacion a master</li>
          <li>-- luego si quiero, puedo pasar a rama master y hacer git rebase experimento, para traer la info de esa rama.</li>
          <li>-- Viendo la historia de sus commits, aparecer√° que mi rama experimento ha existido, pero ha tenido siempre la misma informacion de master, es decir, es como si no hubiera pasado nada fuera de la rama master,</li>
          <li>--- PERO, en realidad pudimos haber hecho cambios en la otra rama.</li>
          <li>--- git branch -D experimento borraria esa rama que antes usamos, pero ya mi informacion esta en master, asi que "no paso nada"</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
     <!--  <div class="parrafos">
        <h1 id="21__">21. Git Stash Guardar cambios en memoria y recuperarlos despu√©s</h1>
        <ol class="parrafo_div">
          <li>Stashed: lista de estados que guarda algunos cambios que hizo en Staging para poder cambiar de rama sin perder el trabajo que todav√≠a no guardamos en un commit.</li>
          <li>√∫til porque a veces no se permite cambiar de rama, √©sto porque tienes cambios sin guardar, y no siempre es un cambio lo suficientemente bueno como para hacer un commit pero no quieres perder ese c√≥digo.</li>
          <li>El stashed permite cambiar de ramas, hacer cambios, trabajar en otras cosas y, m√°s adelante, retomar el trabajo con los archivos que ten√≠as en Staging pero que podemos recuperar ya que los guardaste en el Stash.</li>
          <li>git stash: guarda el trabajo actual del Staging en una lista dise√±ada para ser temporal llamada Stash, para que pueda ser recuperado en el futuro.   </li>
          <li>Puede poner un mensaje en el stash, para asi diferenciarlos en git stash list por si tienes varios elementos en el stash : git stash save "mensaje"</li>
          <li>Obtener elelmentos del stash: El stashed se comporta como una Stack de datos comport√°ndose de manera tipo LIFO (Last In, First Out, ¬´√∫ltimo en entrar, primero en salir¬ª), as√≠ puedes acceder al m√©todo pop.</li>
          <li>-- pop: recuperar√° y sacar√° de la lista el √∫ltimo estado del stashed y lo insertar√° en el staging area, por lo que es importante saber en qu√© branch te encuentras para poder recuperarlo, ya que el stash ser√° agn√≥stico a la rama o estado en el que te encuentres, siempre recuperar√° los cambios que hiciste en el lugar que lo llamas.</li>
          <li>Para recuperar los √∫ltimos cambios desde el stash a tu staging area: git stash pop</li>
          <li>Para aplicar los cambios de un stash espec√≠fico y eliminarlo del stash: git stash pop stash@{< num_stash >}</li>
          <li>Para retomar los cambios de una posici√≥n espec√≠fica del Stash: git stash apply stash@{< num_stash >}</li>
          <li>-- Donde el < num_stash > lo obtienes desde el git stash list</li>
          <li>Para ver la lista de cambios guardados en Stash y poder recuperarlos o hacer algo con ellos: git stash list</li>
          <li>Retomar los cambios de una posici√≥n espec√≠fica del Stash || Aplica los cambios de un stash espec√≠fico</li>
          <li>Para crear una rama y aplicar el stash mas reciente: git stash branch < nombreDeLaRama ></li>
          <li>Si deseas crear una rama y aplicar un stash espec√≠fico (obtenido desde git stash list): git stash branch nombre_de_rama stash@{< num_stash >}</li>
          <li>Al utilizar estos comandos crear√°s una rama con el nombre < nombreDeLaRama >, te pasar√°s a ella y tendr√°s el stash especificado en tu staging area.</li>
          <li>Para eliminar los cambios m√°s recientes dentro del stash (el elemento 0): git stash drop</li>
          <li>Si en cambio conoces el √≠ndice del stash que quieres borrar (mediante git stash list): git stash drop stash@{< num_stash >}</li>
          <li>-- Donde el < num_stash > es el √≠ndice del cambio guardado.</li>
          <li>Si en cambio deseas eliminar todos los elementos del stash: git stash clear</li>
          <li>Consideraciones:</li>
          <li>-- El cambio m√°s reciente (al crear un stash) SIEMPRE recibe el valor 0 y los que estaban antes aumentan su valor.</li>
          <li>-- Al crear un stash tomar√° los archivos que han sido modificados y eliminados. Para que tome un archivo creado es necesario agregarlo al Staging Area con git add [nombre_archivo] con la intenci√≥n de que git tenga un seguimiento de ese archivo, o tambi√©n utilizando el comando git stash -u (que guardar√° en el stash los archivos que no est√©n en el staging).</li>
          <li>-- Al aplicar un stash este no se elimina, es buena pr√°ctica eliminarlo.</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="22__">22. Git Clean limpiar tu proyecto de archivos no deseados</h1>
        <ol class="parrafo_div">
          <li>git clean: borra documentos copiados, pero debes usarlo con otro atributo.</li>
          <li>-- git clean --dry-run : Ver que archivos ir√© a borrar.</li>
          <li>-- git clean -f : borra esos archivos</li>
          <li>-- ya que Git ignora carpetas, la carpeta copiada debes borrarla a mano.</li>
          <li>Si tambien hay imagenes que son copias, o cualquier tipo de archivo... Si estan en .gitignore no se borraran.</li>
          <li>Comentario: El parametro -d ayuda con el borrado de carpetas untracked. Por ejemplo: git clean -df hubiera borrado la carpeta ‚Äúcss - copia"</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="23__">23. Git cherry-pick traer commits viejos al head de un branch</h1>
        <ol class="parrafo_div">
          <li>Mala practica</li>
          <li>has una modificacion a un archivo, y hazle stash, luego has un git stash branch nuevarama, en esa nueva rama has el add y commit</li>
          <li>ve a master y escribe git cherry-pick numeroDeCommit  (numeroDeCommit numero del commit que quiera traer de otra rama)</li>
          <li>Y si quieres puedes unir el master a la rama numeroDeCommit</li>
          <li>-- desde master: git merge numeroDeCommit</li>
          <li>-- Si trae un conflicto, escoges con que cambio quedarte, y listo.</li>
          <li>Comentario:</li>
          <li>-- Este comando permite coger uno o varios commits de otra rama sin tener que hacer un merge completo. Gracias a cherry-pick, podr√≠as aplicar los commits relacionados con nuestra funcionalidad de Facebook en nuestra rama master sin necesidad de hacer un merge.</li>
          <li>-- Para demostrar c√≥mo utilizar git cherry-pick, suponga que tiene un repositorio con el siguiente estado de rama:</li>
          <li>a - b - c - d   Master</li>
          <li style="margin-left: 60px;">         \</li>
          <li style="margin-left: 70px;">           e - f - g Feature</li>
          <li>-- El uso de git cherry-pick es sencillo y se puede ejecutar de la siguiente manera: git checkout master.</li>
          <li>-- En este ejemplo, commitSha es una referencia de confirmaci√≥n. Puedes encontrar una referencia de confirmaci√≥n utilizando el comando git log. En este caso, imaginemos que queremos utilizar la confirmaci√≥n ‚Äòf‚Äô en la rama master. Para ello, primero debemos asegurarnos de que estamos trabajando con esa rama master: git cherry-pick f</li>
          <li>-- Una vez ejecutado, el historial de Git se ver√° as√≠:</li>
          <li>a - b - c - d - f   Master</li>
          <li style="margin-left: 60px;">\</li>
          <li style="margin-left: 70px;">e - f - g Feature</li>
          <li>-- La confirmaci√≥n f se ha sido introducido con √©xito en la rama de funcionalidad</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="24__">24. Reconstruir commits en Git con amend</h1>
        <ol class="parrafo_div">
          <li>git commit --amend : une los cambios que olvidas subir, en caso de que hayas hecho algun cambio y lo olvides agregar en el commit, subira esos cambios al commit.</li>
          <li>Resumen: si haces commit, pero olvidas agregar un cambio, pues hacemos el add de los cambios, y luego usamos git commit --amend, abre la consola de vim, y dejo el mismo mensaje si quiero.</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="25__">25. Git Reset y Reflog √∫sese en caso de emergencia</h1>
        <ol class="parrafo_div">
          <li>Comentario:</li>
          <li>-- Git nunca olvida, git reflog</li>
          <li>-- Git guarda todos los cambios aunque decidas borrarlos, al borrar un cambio lo que est√°s haciendo s√≥lo es actualizar la punta del branch, para gestionar √©stas puntas existe un mecanismo llamado registros de referencia o reflogs.</li>
          <li>-- La gesti√≥n de estos cambios es mediante los hash‚Äôes de referencia (o ref) que son apuntadores a los commits.</li>
          <li>-- Los recoges registran cu√°ndo se actualizaron las referencias de Git en el repositorio local (s√≥lo en el local), por lo que si deseas ver c√≥mo has modificado la historia puedes utilizar el comando:</li>
          <li>-- git reflog</li>
          <li>-- Muchos comandos de Git aceptan un par√°metro para especificar una referencia o ‚Äúref‚Äù, que es un puntero a una confirmaci√≥n sobre todo los comandos:</li>
          <li>--- git checkout Puedes moverte sin realizar ning√∫n cambio al commit exacto de la ref</li>
          <li>--- git checkout eff544f</li>
          <li>--- git reset: Har√° que el √∫ltimo commit sea el pasado por la ref, usar este comando s√≥lo si sabes exactamente qu√© est√°s haciendo</li>
          <li>--- git reset --hard eff544f # Perder√° todo lo que se encuentra en staging y en el Working directory y se mover√° el head al commit eff544f</li>
          <li>--- git reset --soft eff544f # Te recuperar√° todos los cambios que tengas diferentes al commit eff544f, los agregar√° al staging area y mover√° el head al commit eff544f</li>
          <li>--- git merge: Puedes hacer merge de un commit en espec√≠fico, funciona igual que con una branch, pero te hace el merge del estado espec√≠fico del commit mandado</li>
          <li>--- git checkout master</li>
          <li>--- git merge eff544f # Fusionar√° en un nuevo commit la historia de master con el momento espec√≠fico en el que vive eff544f</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="26__">26. Buscar en archivos y commits de Git con Grep y log</h1>
        <ol class="parrafo_div">
          <li>Descripcion:</li>
          <li>A medida que el proyecto se hace grande querr√© buscar ciertas cosas.</li>
          <li>Por ejemplo: ¬øcu√°ntas veces en mi proyecto utilizo la palabra color?</li>
          <li>Para buscar utilizo el comando git grep color y buscar√° en todo el proyecto los archivos en donde est√° la palabra color.</li>
          <li>-- Con git grep -n color saldr√° un output el cual dir√° en qu√© l√≠nea est√° lo que estamos buscando.</li>
          <li>-- Con git grep -c color saldr√° un output el cual dir√° cu√°ntas veces se repite esa palabra y en qu√© archivo.</li>
          <li>-- Si quiero buscar cu√°ntas veces utilizo un atributo de HTML lo hacemos con git grep -c "<p>".</li>
          <li>-- git grep -n platzi -- en que lineas use la palabra platzi</li>
          <li>-- git grep -c la -- cuantas veces use la palabra la</li>
          <li>-- git grep -c ‚Äú<p>‚Äù‚Äì> cuantas veces use la etiqueta <p></li>
          <li>-- git log-S ‚Äúcabecera‚Äù -- cuantas veces use la palabra cabecera en todos los commits.</li>
          <li>-- grep‚Äì> para los archivos</li>
          <li>-- log -- para los commits.</li>
          <li>-- Use el git log -S ‚Äúpalabra‚Äù no trae el conteo, trae las palabras parecidas a las que estamos buscando.</li>
          <li>-- Es mejor que uses git log --all --oneline | grep ‚Äúcabecera‚Äù, te trae los commits en donde se encuentra la palabra.</li>
        </ol>
      </div> -->

<!-- ________________________________________________________________________________________________ -->
      <!-- <div class="parrafos">
        <h1 id="27__">27. Comandos y recursos colaborativos en Git y GitHub</h1>
        <ol class="parrafo_div">
          <li>git shortlog -sn : muestra cuantos commit han hecho cada miembros del equipo.</li>
          <li>-- git shortlog : muestra mensajes de los commits</li>
          <li>git shortlog -sn --all : muestra cuantos commits hizo cada miembro del equipo, incluso los que han sido eliminado</li>
          <li>git shortlog -sn --all --no-merge = muestra cuantos commit han hecho cada miembros quitando los eliminados sin los merges</li>
          <li>git config --global alias.stats "shortlog -sn --all --no-merges" le estamos diciendo a git que en su config global de mi maquina actual, agregue un alias con nombre "stats" y ese alias almacenara el comando shortlog -sn --all --no-merges  es decir que cuando ejecutemos git stats nos traera los que original mente nos traeria ese comand</li>
          <li>git blame nombrearchivo = muestra quien hizo cada cosa linea por linea</li>
          <li>-- git blame -c nombrearchivo  es como el comando de arriba, pero con identacion</li>
          <li>git nombredelcomando --help = muestra en google como funciona ese comando.</li>
          <li>git blame nombrearchivo -L35,50= muestra quien hizo cada cosa linea por linea indic√°ndole desde que linea ver ejemplo -L35,53 tambien se le puede agregar el '-c' al final</li>
          <li>git branch -r = se muestran todas las ramas remotas</li>
          <li>git branch -a = se muestran todas las ramas tanto locales como remotas</li>
        </ol>
      </div>
    </div>

    <p>Si borro un archivo, y doy git checkout -- . me regresa al ultimo commit guardado</p> -->

  </div>
</body>
</html>